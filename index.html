<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combinador de Im치genes con IA</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>游뿏</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(-45deg, #0d0221, #0c164f, #1e1b4b, #4338ca);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .styled-button {
            transition: all 0.3s ease-in-out;
            border: 2px solid;
            font-weight: 600;
            background-color: transparent;
        }
        .styled-button:hover:not(:disabled) {
            transform: scale(1.05) translateY(-2px);
            color: #ffffff;
        }
        .styled-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            border-color: #6366f1; /* indigo-500 */
            color: #818cf8; /* indigo-400 */
            box-shadow: 0 0 8px rgba(99, 102, 241, 0.4);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #6366f1;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.7);
        }
         .btn-secondary {
            border-color: #3b82f6; /* blue-500 */
            color: #60a5fa; /* blue-400 */
             box-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
        }

        .loader {
            border: 4px solid #374151;
            border-top: 4px solid #6366f1; /* indigo-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-box {
            background-color: rgba(17, 24, 39, 0.5);
            border: 2px dashed #4f46e5; /* indigo-600 */
            transition: all 0.3s ease;
            box-shadow: 0 0 8px rgba(79, 70, 229, 0.3);
        }
        .upload-box:hover {
            border-color: #818cf8; /* indigo-400 */
            box-shadow: 0 0 12px rgba(129, 140, 248, 0.5);
            transform: scale(1.05);
        }
        .upload-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 0.5rem;
        }
        .upload-box .icon, .upload-box .text { z-index: 5; }
        .upload-box.has-image .icon, .upload-box.has-image .text { opacity: 0; }
        
        .result-container {
             background-color: rgba(17, 24, 39, 0.5);
             border-color: rgba(99, 102, 241, 0.4);
             box-shadow: 0 0 15px rgba(99, 102, 241, 0.2);
        }

        .gemini-icon-spin {
            animation: spin 1s linear infinite;
        }
        
        .modal-overlay {
            background-color: rgba(0,0,0,0.7);
            z-index: 999;
        }
        .modal-content {
            background-color: #1e1b4b;
            box-shadow: 0 0 25px rgba(99, 102, 241, 0.5);
        }
        #camera-view video {
            transform: scaleX(-1);
        }

        #mask-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #floating-image-container {
            position: absolute;
            touch-action: none; /* Required for interact.js */
            user-select: none;
            box-sizing: border-box;
            border: 2px solid rgba(99, 102, 241, 0.7); /* Dashed border to show it's an element */
        }
        #floating-image-container img {
            width: 100%;
            height: 100%;
            pointer-events: none; /* Make sure clicks go through the image to the container for dragging */
        }
        .interaction-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #6366f1;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 10;
        }
        #resize-handle {
            bottom: -10px;
            right: -10px;
            cursor: se-resize;
        }
        #rotate-handle {
            top: -10px;
            right: -10px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>') 16 16, auto;
        }
        /* Carousel Styles */
        .carousel {
            overflow-x: scroll;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
        }
        .carousel::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }
        .carousel-track {
            display: flex;
            transition: transform 0.3s ease-in-out;
        }
        .carousel-slide {
            flex: 0 0 100%;
            width: 100%;
            scroll-snap-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .carousel-btn {
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0,0,0,0.4);
            border-radius: 50%;
            z-index: 10;
        }
        .carousel-btn:hover {
             background-color: rgba(0,0,0,0.7);
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen p-4">
    <div class="container mx-auto max-w-3xl text-center">
        
        <h1 class="text-4xl md:text-5xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-indigo-500 text-transparent bg-clip-text">
            Combinador de Im치genes IA
        </h1>
        <p class="text-gray-300 mb-8">
            Sube hasta 3 im치genes, describe c칩mo combinarlas y deja que la IA cree algo nuevo.
        </p>

        <!-- Image upload section -->
        <div id="upload-container" class="flex justify-center items-center gap-2 sm:gap-4 mb-6">
             <!-- Slots are generated by JS now -->
        </div>

        <!-- Input section -->
        <div class="flex items-center gap-2 w-full mb-6">
            <div class="relative flex-grow">
                <input type="text" id="prompt-input" class="w-full pl-3 pr-10 py-1 text-xs bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Describe tu idea...">
                <button id="rewrite-btn" class="absolute inset-y-0 right-0 flex items-center pr-3 group" title="Mejorar prompt con IA">
                    <svg id="gemini-icon" class="w-5 h-5 text-gray-400 group-hover:text-indigo-400 transition" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 5.5C12 5.22386 12.2239 5 12.5 5C12.7761 5 13 5.22386 13 5.5V6.5C13 6.77614 12.7761 7 12.5 7C12.2239 7 12 6.77614 12 6.5V5.5ZM8.5 7C8.22386 7 8 7.22386 8 7.5C8 7.77614 8.22386 8 8.5 8H9.5C9.77614 8 10 7.77614 10 7.5C10 7.22386 9.77614 7 9.5 7H8.5ZM6 12.5C6 12.239 5.77614 12 5.5 12H4.5C4.22386 12 4 12.2239 4 12.5C4 12.7761 4.22386 13 4.5 13H5.5C5.77614 13 6 12.7761 6 12.5ZM8.5 17C8.22386 17 8 17.2239 8 17.5C8 17.7761 8.22386 18 8.5 18H9.5C9.77614 18 10 17.7761 10 17.5C10 17.2239 9.77614 17 9.5 17H8.5ZM13 17.5C13 17.2239 12.7761 17 12.5 17C12.2239 17 12 17.2239 12 17.5V18.5C12 18.7761 12.2239 19 12.5 19C12.7761 19 13 18.7761 13 18.5V17.5ZM19 12.5C19 12.2239 18.7761 12 18.5 12H17.5C17.2239 12 17 12.2239 17 12.5C17 12.7761 17.2239 13 17.5 13H18.5C18.7761 13 19 12.7761 19 12.5ZM15.5 8C15.7761 8 16 7.77614 16 7.5C16 7.22386 15.7761 7 15.5 7H14.5C14.2239 7 14 7.22386 14 7.5C14 7.77614 14.2239 8 14.5 8H15.5Z" fill="currentColor"></path></svg>
                </button>
            </div>
            <button id="generate-btn" class="styled-button btn-primary py-1 px-3 text-xs rounded-md whitespace-nowrap">
                Combinar
            </button>
        </div>
        
        <!-- Edit Section -->
        <div id="edit-section" class="hidden w-full mb-6">
            <div class="relative flex flex-col sm:flex-row gap-2">
                <input type="text" id="edit-prompt-input" class="w-full pl-3 py-1 text-xs bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Edita la imagen actual. Ej: A침ade un cielo estrellado...">
                <button id="edit-btn" class="styled-button btn-primary py-1 px-4 text-xs rounded-lg whitespace-nowrap">
                    Editar
                </button>
            </div>
        </div>

        <!-- Inpaint Section -->
        <div id="inpaint-section" class="hidden w-full mb-6">
            <p class="text-indigo-300 mb-2 text-sm">Dibuja sobre la imagen para seleccionar un 치rea, luego describe el cambio.</p>
            <div class="relative flex flex-col sm:flex-row gap-4">
                <input type="text" id="inpaint-prompt-input" class="w-full pl-3 py-2 text-sm bg-gray-800/50 border border-blue-500/50 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition placeholder-gray-500" placeholder="Ej: un gato negro sentado ah칤...">
                <button id="inpaint-apply-btn" class="styled-button btn-secondary py-2 px-5 text-sm rounded-lg whitespace-nowrap">Aplicar M치scara</button>
            </div>
        </div>

        <!-- Overlay Section -->
        <div id="overlay-section" class="hidden w-full mb-6 p-3 border border-indigo-500/30 rounded-lg bg-gray-900/20">
             <p class="text-indigo-300 mb-2 text-xs text-left">A침ade una imagen superpuesta. Arr치strala, redimensi칩nala y r칩tala sobre la imagen de fondo.</p>
            <div class="flex flex-col sm:flex-row items-center gap-2">
                <button id="upload-overlay-btn" class="styled-button btn-secondary py-1 px-3 text-xs rounded-md whitespace-nowrap">Cargar Imagen Flotante</button>
                <input type="file" id="overlay-image-upload" class="hidden" accept="image/*">
                <div class="relative flex-grow w-full sm:w-auto">
                    <input type="text" id="overlay-prompt-input" class="w-full pl-3 pr-10 py-1 text-xs bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Ej: un fantasma transparente sobre el bosque...">
                </div>
                <button id="implement-overlay-btn" class="styled-button btn-primary py-1 px-3 text-xs rounded-md whitespace-nowrap flex items-center gap-1.5">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor"><path d="M5 4a1 1 0 00-2 0v7.268a2 2 0 000 3.464V16a1 1 0 102 0v-1.268a2 2 0 000-3.464V4zM11 4a1 1 0 10-2 0v1.268a2 2 0 000 3.464V16a1 1 0 102 0V8.732a2 2 0 000-3.464V4zM16 3a1 1 0 011 1v7.268a2 2 0 010 3.464V16a1 1 0 11-2 0v-1.268a2 2 0 010-3.464V4a1 1 0 011-1z" /></svg>
                    <span>Implementar</span>
                </button>
            </div>
        </div>

        <!-- Result section with Carousel -->
        <div id="result-container" class="result-container relative w-full border rounded-lg p-2 mt-6 min-h-[300px] flex items-center justify-center shadow-inner">
             <button id="prev-btn" class="carousel-btn hidden absolute left-2 p-2 text-white"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
            <div id="carousel" class="carousel w-full h-full">
                <canvas id="mask-canvas" class="hidden"></canvas>
                <div id="carousel-track" class="carousel-track h-full">
                    <div id="placeholder-slide" class="carousel-slide">
                         <div id="placeholder" class="text-gray-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="currentColor" class="bi bi-image-alt mb-3 inline-block" viewBox="0 0 16 16"><path d="M7 2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0m4.225 4.053a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L.002 13V3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1.172a2.999 2.999 0 0 1-2.121-.879l-4.144-4.143a.5.5 0 0 0-.707 0L2.95 11.536l2.614-2.354a.5.5 0 0 0 .63-.062l2.66 1.772 3.71-3.71a.5.5 0 0 0 .093-.577z"/></svg>
                            <p>Tu imagen combinada aparecer치 aqu칤.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div id="floating-image-container" class="hidden">
                <img id="floating-image" src="" alt="Imagen flotante">
                <div id="resize-handle" class="interaction-handle"></div>
                <div id="rotate-handle" class="interaction-handle"></div>
            </div>
             <button id="next-btn" class="carousel-btn hidden absolute right-2 p-2 text-white"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></button>
            <div id="loader" class="hidden loader absolute"></div>
            <div id="error-message" class="hidden text-red-400 absolute"></div>
            <div id="save-actions" class="hidden absolute bottom-4 right-4 z-20 flex gap-2">
                <button id="save-btn" class="styled-button btn-secondary py-1 px-3 text-xs rounded-md whitespace-nowrap">Guardar</button>
                <button id="save-album-btn" class="styled-button btn-primary py-1 px-3 text-xs rounded-md whitespace-nowrap">Guardar 츼lbum</button>
            </div>
        </div>

    </div>

    <!-- Modals -->
    <div id="source-modal" class="modal-overlay hidden fixed inset-0 flex items-center justify-center">
        <div class="modal-content p-6 rounded-lg text-center">
            <h3 class="text-lg font-medium mb-4">Seleccionar Fuente</h3>
            <div class="flex gap-4">
                <button id="from-camera-btn" class="styled-button btn-primary flex-1 py-2 px-4 rounded-lg">Tomar Foto</button>
                <button id="from-file-btn" class="styled-button btn-secondary flex-1 py-2 px-4 rounded-lg">Elegir Archivo</button>
            </div>
            <button id="close-source-modal-btn" class="mt-4 text-gray-400 hover:text-white">Cancelar</button>
        </div>
    </div>
    <div id="camera-modal" class="modal-overlay hidden fixed inset-0 flex items-center justify-center p-4">
        <div class="modal-content p-4 rounded-lg text-center w-full max-w-lg">
            <video id="camera-view" class="w-full rounded-md mb-4" autoplay playsinline></video>
            <canvas id="camera-canvas" class="hidden"></canvas>
            <button id="capture-btn" class="styled-button btn-primary w-full py-2 px-4 rounded-lg mb-2">Capturar</button>
            <button id="close-camera-modal-btn" class="text-gray-400 hover:text-white">Cerrar</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const generateBtn = document.getElementById('generate-btn');
        const saveActions = document.getElementById('save-actions');
        const saveBtn = document.getElementById('save-btn'); // Bot칩n individual
        const promptInput = document.getElementById('prompt-input');
        const rewriteBtn = document.getElementById('rewrite-btn');
        const geminiIcon = document.getElementById('gemini-icon');
        const uploadContainer = document.getElementById('upload-container');
        
        const resultContainer = document.getElementById('result-container');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('error-message');
        const saveAlbumBtn = document.getElementById('save-album-btn');
        const placeholderSlide = document.getElementById('placeholder-slide');

        // Edit Section
        const editSection = document.getElementById('edit-section');
        const editPromptInput = document.getElementById('edit-prompt-input');
        const editBtn = document.getElementById('edit-btn');

        // Inpaint Section
        const inpaintSection = document.getElementById('inpaint-section');
        const inpaintPromptInput = document.getElementById('inpaint-prompt-input');
        const inpaintApplyBtn = document.getElementById('inpaint-apply-btn');
        
        // Overlay Section
        const overlaySection = document.getElementById('overlay-section');
        const uploadOverlayBtn = document.getElementById('upload-overlay-btn');
        const overlayImageUpload = document.getElementById('overlay-image-upload');
        const overlayPromptInput = document.getElementById('overlay-prompt-input');
        const implementOverlayBtn = document.getElementById('implement-overlay-btn');
        const floatingImageContainer = document.getElementById('floating-image-container');
        const floatingImage = document.getElementById('floating-image');

        // Carousel Elements
        const carousel = document.getElementById('carousel');
        const carouselTrack = document.getElementById('carousel-track');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        // Modal Elements
        const sourceModal = document.getElementById('source-modal');
        const cameraModal = document.getElementById('camera-modal');
        const fromCameraBtn = document.getElementById('from-camera-btn');
        const fromFileBtn = document.getElementById('from-file-btn');
        const closeSourceModalBtn = document.getElementById('close-source-modal-btn');
        const closeCameraModalBtn = document.getElementById('close-camera-modal-btn');
        const captureBtn = document.getElementById('capture-btn');
        const video = document.getElementById('camera-view');
        const canvas = document.getElementById('camera-canvas');
        const maskCanvas = document.getElementById('mask-canvas');
        const maskCtx = maskCanvas.getContext('2d');



        // --- State Variables ---
        const NUM_SLOTS = 3;
        let uploadedImagesData = new Array(NUM_SLOTS).fill(null);
        let generatedImagesHistory = [];
        let currentImageIndex = 0;
        let currentSlotIndex = null;
        let cameraStream = null;
        let isMaskingActive = false;
        let isDrawing = false;
        let overlayImageData = null;

        // La API Key se gestiona de forma segura en el servidor.

        // --- Initialization ---
        function createUploadSlots() {
            for (let i = 0; i < NUM_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.className = 'upload-slot';
                slot.dataset.index = i;
                slot.innerHTML = `
                    <div class="upload-box relative flex flex-col items-center justify-center cursor-pointer rounded-lg w-20 h-20 md:w-28 md:h-28">
                        <svg class="icon h-6 w-6 mb-1 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>
                        <span class="text text-xs text-gray-400">Imagen ${i + 1}</span>
                        <img id="thumbnail-${i}" src="" class="hidden">
                    </div>
                    <input type="file" id="image-upload-${i}" class="hidden" accept="image/*">
                `;
                uploadContainer.appendChild(slot);

                slot.addEventListener('click', () => {
                    currentSlotIndex = i;
                    sourceModal.classList.remove('hidden');
                });
                
                const fileInput = slot.querySelector('input[type="file"]');
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => processImage(e.target.result, i);
                        reader.readAsDataURL(file);
                    }
                });
            }
        }
        createUploadSlots();


        // --- Modal & Camera Logic ---
        closeSourceModalBtn.addEventListener('click', () => sourceModal.classList.add('hidden'));
        
        fromFileBtn.addEventListener('click', () => {
            sourceModal.classList.add('hidden');
            document.getElementById(`image-upload-${currentSlotIndex}`).click();
        });

        fromCameraBtn.addEventListener('click', () => {
            sourceModal.classList.add('hidden');
            cameraModal.classList.remove('hidden');
            startCamera();
        });
        
        closeCameraModalBtn.addEventListener('click', stopCamera);

        captureBtn.addEventListener('click', () => {
            const context = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            if (video.style.transform === 'scaleX(-1)') {
                context.translate(canvas.width, 0);
                context.scale(-1, 1);
            }

            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/png');
            processImage(dataUrl, currentSlotIndex);
            stopCamera();
        });
        
        async function startCamera() {
            const rearCameraConstraints = { video: { facingMode: { ideal: 'environment' } } };
            const frontCameraConstraints = { video: { facingMode: 'user' } };
            
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia(rearCameraConstraints);
                video.style.transform = 'scaleX(1)';
            } catch (err) {
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia(frontCameraConstraints);
                    video.style.transform = 'scaleX(-1)';
                } catch (fallbackErr) {
                    showError("No se pudo acceder a la c치mara. Revisa los permisos.");
                    stopCamera();
                    return;
                }
            }
            video.srcObject = cameraStream;
        }
        
        function stopCamera() {
            if (cameraStream) cameraStream.getTracks().forEach(track => track.stop());
            cameraModal.classList.add('hidden');
        }

        // --- Image Processing ---
        function processImage(dataUrl, index) {
            const thumbnail = document.getElementById(`thumbnail-${index}`);
            const uploadBox = thumbnail.closest('.upload-box');
            
            thumbnail.src = dataUrl;
            thumbnail.classList.remove('hidden');
            uploadBox.classList.add('has-image');
            
            const [header, base64Data] = dataUrl.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            uploadedImagesData[index] = { mimeType, data: base64Data };
            sourceModal.classList.add('hidden'); // Auto-close modal
        }

        // --- Overlay Image Logic ---
        uploadOverlayBtn.addEventListener('click', () => overlayImageUpload.click());

        overlayImageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Reset previous transformations before showing the new image
                    floatingImageContainer.style.transform = '';
                    floatingImageContainer.style.width = '150px'; // Set initial small size
                    floatingImageContainer.style.height = ''; // Let height be auto
                    floatingImageContainer.removeAttribute('data-x');
                    floatingImageContainer.removeAttribute('data-y');
                    floatingImageContainer.removeAttribute('data-rotate');
                    floatingImageContainer.removeAttribute('data-scale');

                    floatingImage.src = e.target.result;
                    floatingImageContainer.classList.remove('hidden');

                    // Center the new small image
                    const parentRect = resultContainer.getBoundingClientRect();
                    const initialX = (parentRect.width - 150) / 2;
                    const initialY = (parentRect.height - 150) / 2; // Approximate height
                    floatingImageContainer.style.transform = `translate(${initialX}px, ${initialY}px)`;
                    floatingImageContainer.setAttribute('data-x', initialX);
                    floatingImageContainer.setAttribute('data-y', initialY);

                    const [header, base64Data] = e.target.result.split(',');
                    overlayImageData = { mimeType: header.match(/:(.*?);/)[1], data: base64Data };
                };
                reader.readAsDataURL(file);
            }
        });

        // --- API & Generation Logic ---
        async function callApiWithBackoff(apiUrl, payload) {
            // Simplified for brevity, production code should have backoff
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error: ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
            }
            return await response.json();
        }

        async function handleImageGeneration(prompt, images, { mask = null, overlay = null } = {}) {
            setLoadingState(true);
            deactivateMasking();
            try {
                // Ahora llamamos a nuestro propio backend
                const apiUrl = '/api/generate';

                // Si hay una imagen superpuesta, el prompt se construye de forma especial
                if (overlay && overlay.image) {
                    const bgImageElement = carouselTrack.children[currentImageIndex].querySelector('img');
                    const bgWidth = bgImageElement.clientWidth;
                    const bgHeight = bgImageElement.clientHeight;

                    prompt = `Toma la primera imagen como fondo (lienzo). El tama침o del lienzo es ${bgWidth}px de ancho por ${bgHeight}px de alto.
                    Ahora, superp칩n la segunda imagen (la imagen flotante) sobre este lienzo.
                    - Posici칩n de la imagen flotante (coordenadas top, left desde la esquina superior izquierda del lienzo): ${Math.round(overlay.y)}px, ${Math.round(overlay.x)}px.
                    - Tama침o de la imagen flotante: ${Math.round(overlay.width)}px de ancho por ${Math.round(overlay.height)}px de alto.
                    - Rotaci칩n de la imagen flotante: ${Math.round(overlay.rotation)} grados.
                    Finalmente, integra la imagen flotante en el fondo aplicando esta instrucci칩n creativa: "${prompt}". La segunda imagen es la que se debe transformar y colocar; la primera es solo el lienzo.`;
                    
                    // El orden es importante: primero el fondo, luego la imagen a superponer
                    images.push(overlay.image);
                }


                const parts = [{ text: prompt }];
                images.forEach(img => parts.push({ inlineData: { mimeType: img.mimeType, data: img.data } }));
                if (mask) parts.push({ inlineData: { mimeType: mask.mimeType, data: mask.data } });
                const payload = { contents: [{ parts }] };

                const result = await callApiWithBackoff(apiUrl, payload);
                const candidate = result?.candidates?.[0];

                if (candidate && candidate.finishReason) {
                    if (candidate.finishReason === 'SAFETY') {
                        throw new Error("La combinaci칩n de im치genes fue bloqueada por motivos de seguridad.");
                    } else if (candidate.finishReason !== 'STOP') {
                        throw new Error(`Generaci칩n bloqueada. Raz칩n: ${candidate.finishReason}`);
                    }
                }
                
                const imagePart = candidate?.content?.parts?.find(p => p.inlineData);
                if (imagePart && imagePart.inlineData.data) {
                    const mimeType = imagePart.inlineData.mimeType || 'image/png';
                    const imageUrl = `data:${mimeType};base64,${imagePart.inlineData.data}`;
                    addImageToCarousel(imageUrl);
                } else {
                    console.error("Invalid API Response:", JSON.stringify(result, null, 2));
                    throw new Error('La respuesta de la API no contiene datos de imagen v치lidos.');
                }
            } catch (error) {
                console.error('Failed to generate image:', error);
                showError(error.message || 'No se pudo generar la imagen.');
            } finally {
                setLoadingState(false);
            }
        }

        generateBtn.addEventListener('click', () => {
            const prompt = promptInput.value.trim();
            const validImages = uploadedImagesData.filter(img => img !== null);
            if (validImages.length === 0) return showError('Por favor, sube al menos una imagen.');
            if (!prompt) return showError('Por favor, describe c칩mo combinar las im치genes.');
            handleImageGeneration(prompt, validImages);
        });

        editBtn.addEventListener('click', () => {
            const prompt = editPromptInput.value.trim();
            if (!prompt) return showError('Por favor, describe c칩mo editar la imagen.');
            if (generatedImagesHistory.length === 0) return showError('No hay imagen para editar.');

            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            const imageData = { mimeType, data: base64Data };
            
            handleImageGeneration(prompt, [imageData]);
        });
        
        rewriteBtn.addEventListener('click', async () => {
            const currentPrompt = promptInput.value;
            if (!currentPrompt) return;

            geminiIcon.classList.add('gemini-icon-spin');
            rewriteBtn.disabled = true;
            try {
                // Ahora llamamos a nuestro propio backend
                const apiUrl = '/api/generate';
                const payload = {
                    contents: [{
                        parts: [{ text: `Reformula y mejora el siguiente prompt para un modelo de generaci칩n de im치genes. S칠 creativo y descriptivo. Devuelve solo el prompt mejorado, sin texto adicional. Prompt original: "${currentPrompt}"` }]
                    }]
                };
                const result = await callApiWithBackoff(apiUrl, payload);
                const newPrompt = result.candidates[0].content.parts[0].text.trim();
                promptInput.value = newPrompt;
            } catch (error) {
                console.error('Error reescribiendo el prompt:', error);
                showError('No se pudo mejorar el prompt.');
            } finally {
                geminiIcon.classList.remove('gemini-icon-spin');
                rewriteBtn.disabled = false;
            }
        });

        // --- Inpainting / Masking Logic ---
        inpaintApplyBtn.addEventListener('click', () => {
            const prompt = inpaintPromptInput.value.trim();
            if (!prompt) return showError('Por favor, describe el cambio para el 치rea seleccionada.');
            if (generatedImagesHistory.length === 0) return showError('No hay imagen para editar.');

            // Get current image
            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            const imageData = { mimeType, data: base64Data };

            // Get mask
            const maskDataUrl = maskCanvas.toDataURL('image/png');
            const [maskHeader, maskBase64Data] = maskDataUrl.split(',');
            const maskMimeType = maskHeader.match(/:(.*?);/)[1];
            const maskData = { mimeType: maskMimeType, data: maskBase64Data };

            handleImageGeneration(prompt, [imageData], { mask: maskData });
        });

        implementOverlayBtn.addEventListener('click', async () => {
            const prompt = overlayPromptInput.value.trim();
            if (!prompt) return showError('Describe c칩mo implementar la imagen flotante.');
            if (!overlayImageData) return showError('Carga una imagen flotante primero.');
            if (generatedImagesHistory.length === 0) return showError('No hay imagen de fondo para editar.');

            // Get base image
            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const baseImage = { mimeType: header.match(/:(.*?);/)[1], data: base64Data };

            // Get overlay image and its transformations
            const overlay = {
                image: overlayImageData,
                x: parseFloat(floatingImageContainer.dataset.x || 0),
                y: parseFloat(floatingImageContainer.dataset.y || 0),
                width: floatingImageContainer.clientWidth,
                height: floatingImageContainer.clientHeight,
                rotation: parseFloat(floatingImageContainer.dataset.rotate || 0),
                scale: parseFloat(floatingImageContainer.dataset.scale || 1)
            };
            
            await handleImageGeneration(prompt, [baseImage], { overlay });

            // Hide and reset the floating image after generation is complete
            floatingImageContainer.classList.add('hidden');
            floatingImage.src = '';
            overlayImageData = null;
            overlayPromptInput.value = ''; // Borra el texto del prompt
            floatingImageContainer.style.transform = '';
            floatingImageContainer.removeAttribute('data-x');
            floatingImageContainer.removeAttribute('data-y');
            floatingImageContainer.removeAttribute('data-rotate');
            floatingImageContainer.removeAttribute('data-scale');
        });

        function activateMasking() {
            isMaskingActive = true;
            maskCanvas.classList.remove('hidden');
            inpaintSection.classList.remove('hidden');
            editSection.classList.add('hidden'); // Hide regular edit

            const currentImageElement = carouselTrack.children[currentImageIndex].querySelector('img');
            if (currentImageElement) {
                maskCanvas.width = currentImageElement.clientWidth;
                maskCanvas.height = currentImageElement.clientHeight;
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            }
        }

        function deactivateMasking() {
            isMaskingActive = false;
            isDrawing = false;
            maskCanvas.classList.add('hidden');
            inpaintSection.classList.add('hidden');
            overlaySection.classList.toggle('hidden', generatedImagesHistory.length === 0);
            if (generatedImagesHistory.length > 0) editSection.classList.remove('hidden');
        }

        // --- Carousel Logic ---
        function addImageToCarousel(imageUrl) {
            generatedImagesHistory.push(imageUrl);
            
            if (placeholderSlide.parentElement) {
                carouselTrack.removeChild(placeholderSlide);
            }

            const slide = document.createElement('div');
            slide.className = 'carousel-slide';
            slide.innerHTML = `<img src="${imageUrl}" class="max-w-full max-h-[512px] h-full rounded-md object-contain">`;
            carouselTrack.appendChild(slide);

            currentImageIndex = generatedImagesHistory.length - 1;
            updateCarousel();
            editPromptInput.value = ''; // Clear edit prompt
        }

        function updateCarousel() {
            carouselTrack.style.transform = `translateX(-${currentImageIndex * 100}%)`;
            
            // Show/hide nav buttons
            prevBtn.classList.toggle('hidden', currentImageIndex === 0);
            nextBtn.classList.toggle('hidden', currentImageIndex === generatedImagesHistory.length - 1);
            
            // Show/hide save buttons and edit section
            const hasImages = generatedImagesHistory.length > 0;
            saveActions.classList.toggle('hidden', !hasImages);
            editSection.classList.toggle('hidden', !hasImages);
            overlaySection.classList.toggle('hidden', !hasImages);
            saveAlbumBtn.classList.toggle('hidden', generatedImagesHistory.length < 2);
            deactivateMasking(); // Deactivate mask when changing image
        }

        saveAlbumBtn.addEventListener('click', async () => {
            if (generatedImagesHistory.length < 2) return;

            setLoadingState(true); // Muestra el loader
            try {
                const zip = new JSZip();
                generatedImagesHistory.forEach((dataUrl, index) => {
                    const base64Data = dataUrl.split(',')[1];
                    zip.file(`imagen-generada-${index + 1}.png`, base64Data, { base64: true });
                });

                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = 'album-imagenes-generadas.zip';
                link.click();
                URL.revokeObjectURL(link.href);
            } catch (error) {
                console.error("Error creando el archivo zip:", error);
                showError("No se pudo crear el 치lbum.");
            } finally {
                setLoadingState(false); // Oculta el loader
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                updateCarousel();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentImageIndex < generatedImagesHistory.length - 1) {
                currentImageIndex++;
                updateCarousel();
            }
        });
        
        let touchstartX = 0;
        let touchendX = 0;

        carousel.addEventListener('touchstart', e => { touchstartX = e.changedTouches[0].screenX }, { passive: true });
        carousel.addEventListener('touchend', e => {
            touchendX = e.changedTouches[0].screenX;
            if (touchendX < touchstartX - 50) nextBtn.click();
            if (touchendX > touchstartX + 50) prevBtn.click();
        });

        // --- Mask Drawing Events ---
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = evt.clientX || evt.touches[0].clientX;
            const clientY = evt.clientY || evt.touches[0].clientY;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function drawOnMask(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const pos = getMousePos(maskCanvas, e);
            maskCtx.lineTo(pos.x, pos.y);
            maskCtx.stroke();
        }

        maskCanvas.addEventListener('mousedown', (e) => {
            if (!isMaskingActive) return;
            isDrawing = true;
            const pos = getMousePos(maskCanvas, e);
            maskCtx.beginPath();
            maskCtx.moveTo(pos.x, pos.y);
            maskCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            maskCtx.lineWidth = 20;
            maskCtx.lineCap = 'round';
            maskCtx.lineJoin = 'round';
        });
        maskCanvas.addEventListener('mouseup', () => { isDrawing = false; });
        maskCanvas.addEventListener('mouseout', () => { isDrawing = false; });
        maskCanvas.addEventListener('mousemove', drawOnMask);

        // --- UI Helper Functions ---
        saveBtn.addEventListener('click', () => {
            if (generatedImagesHistory.length > 0) {
                 const link = document.createElement('a');
                 link.href = generatedImagesHistory[currentImageIndex];
                 link.download = `imagen-generada-${currentImageIndex + 1}.png`;
                 link.click();
            }
        });

        function setLoadingState(isLoading) {
            hideError();
            loader.classList.toggle('hidden', !isLoading);
            generateBtn.disabled = isLoading;
            editBtn.disabled = isLoading;
            inpaintApplyBtn.disabled = isLoading;
            implementOverlayBtn.disabled = isLoading;
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideError() {
            errorMessage.classList.add('hidden');
        }

        // Rename edit button and add listener for masking
        editBtn.textContent = 'Editar 츼rea';
        editBtn.addEventListener('click', activateMasking);

        // --- Interact.js for Floating Image ---
        function updateTransform(target) {
            const x = parseFloat(target.getAttribute('data-x')) || 0;
            const y = parseFloat(target.getAttribute('data-y')) || 0;
            const angle = parseFloat(target.getAttribute('data-rotate')) || 0;
            target.style.transform = `translate(${x}px, ${y}px) rotate(${angle}deg)`;
        }

        interact(floatingImageContainer).draggable({
            listeners: {
                move(event) {
                    const target = event.target;
                    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                    updateTransform(target);
                }
            },
            inertia: true,
            modifiers: [interact.modifiers.restrictRect({ restriction: 'parent', endOnly: true })]
        });

        interact('#resize-handle').draggable({
            onmove: function (event) {
                const target = floatingImageContainer;
                const rect = target.getBoundingClientRect();
                
                target.style.width = rect.width + event.dx + 'px';
                target.style.height = rect.height + event.dy + 'px';
            },
        });

        interact('#rotate-handle').draggable({
            onmove: function (event) {
                const target = floatingImageContainer;
                const rect = target.getBoundingClientRect();
                const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                
                const angle = Math.atan2(event.clientY - center.y, event.clientX - center.x);
                const currentAngle = (parseFloat(target.getAttribute('data-rotate')) || 0) * (Math.PI / 180);
                const newAngleDeg = (angle * (180 / Math.PI)) + 90; // Adjust for initial handle position
                
                target.setAttribute('data-rotate', newAngleDeg);
                updateTransform(target);
            }
        });
    </script>
</body>
</html>
