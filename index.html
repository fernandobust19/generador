<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combinador de Imágenes con IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(-45deg, #0d0221, #0c164f, #1e1b4b, #4338ca);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .styled-button {
            transition: all 0.3s ease-in-out;
            border: 2px solid;
            font-weight: 600;
            background-color: transparent;
        }
        .styled-button:hover:not(:disabled) {
            transform: scale(1.05) translateY(-2px);
            color: #ffffff;
        }
        .styled-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            border-color: #6366f1; /* indigo-500 */
            color: #818cf8; /* indigo-400 */
            box-shadow: 0 0 8px rgba(99, 102, 241, 0.4);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #6366f1;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.7);
        }
         .btn-secondary {
            border-color: #3b82f6; /* blue-500 */
            color: #60a5fa; /* blue-400 */
             box-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
        }

        .loader {
            border: 4px solid #374151;
            border-top: 4px solid #6366f1; /* indigo-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-box {
            background-color: rgba(17, 24, 39, 0.5);
            border: 2px dashed #4f46e5; /* indigo-600 */
            transition: all 0.3s ease;
            box-shadow: 0 0 8px rgba(79, 70, 229, 0.3);
        }
        .upload-box:hover {
            border-color: #818cf8; /* indigo-400 */
            box-shadow: 0 0 12px rgba(129, 140, 248, 0.5);
            transform: scale(1.05);
        }
        .upload-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 0.5rem;
        }
        .upload-box .icon, .upload-box .text { z-index: 5; }
        .upload-box.has-image .icon, .upload-box.has-image .text { opacity: 0; }
        
        .result-container {
             background-color: rgba(17, 24, 39, 0.5);
             border-color: rgba(99, 102, 241, 0.4);
             box-shadow: 0 0 15px rgba(99, 102, 241, 0.2);
        }

        .gemini-icon-spin {
            animation: spin 1s linear infinite;
        }
        
        .modal-overlay {
            background-color: rgba(0,0,0,0.7);
            z-index: 999;
        }
        .modal-content {
            background-color: #1e1b4b;
            box-shadow: 0 0 25px rgba(99, 102, 241, 0.5);
        }
        #camera-view video {
            transform: scaleX(-1);
        }

        #mask-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* Carousel Styles */
        .carousel {
            overflow-x: scroll;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
        }
        .carousel::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }
        .carousel-track {
            display: flex;
            transition: transform 0.3s ease-in-out;
        }
        .carousel-slide {
            flex: 0 0 100%;
            width: 100%;
            scroll-snap-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .carousel-btn {
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0,0,0,0.4);
            border-radius: 50%;
            z-index: 10;
        }
        .carousel-btn:hover {
             background-color: rgba(0,0,0,0.7);
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen p-4">
    <div class="container mx-auto max-w-3xl text-center">
        
        <h1 class="text-4xl md:text-5xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-indigo-500 text-transparent bg-clip-text">
            Combinador de Imágenes IA
        </h1>
        <p class="text-gray-300 mb-8">
            Sube hasta 3 imágenes, describe cómo combinarlas y deja que la IA cree algo nuevo.
        </p>

        <!-- Image upload section -->
        <div id="upload-container" class="flex justify-center items-center gap-2 sm:gap-4 mb-6">
             <!-- Slots are generated by JS now -->
        </div>

        <!-- Input section -->
        <div class="relative w-full mb-6">
            <input type="text" id="prompt-input" class="w-full pl-3 pr-10 py-2 text-sm bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Ej: Fusiona las imágenes en un estilo de acuarela...">
            <button id="rewrite-btn" class="absolute inset-y-0 right-0 flex items-center pr-3 group" title="Mejorar prompt con IA">
                 <svg id="gemini-icon" class="w-5 h-5 text-gray-400 group-hover:text-indigo-400 transition" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 5.5C12 5.22386 12.2239 5 12.5 5C12.7761 5 13 5.22386 13 5.5V6.5C13 6.77614 12.7761 7 12.5 7C12.2239 7 12 6.77614 12 6.5V5.5ZM8.5 7C8.22386 7 8 7.22386 8 7.5C8 7.77614 8.22386 8 8.5 8H9.5C9.77614 8 10 7.77614 10 7.5C10 7.22386 9.77614 7 9.5 7H8.5ZM6 12.5C6 12.239 5.77614 12 5.5 12H4.5C4.22386 12 4 12.2239 4 12.5C4 12.7761 4.22386 13 4.5 13H5.5C5.77614 13 6 12.7761 6 12.5ZM8.5 17C8.22386 17 8 17.2239 8 17.5C8 17.7761 8.22386 18 8.5 18H9.5C9.77614 18 10 17.7761 10 17.5C10 17.2239 9.77614 17 9.5 17H8.5ZM13 17.5C13 17.2239 12.7761 17 12.5 17C12.2239 17 12 17.2239 12 17.5V18.5C12 18.7761 12.2239 19 12.5 19C12.7761 19 13 18.7761 13 18.5V17.5ZM19 12.5C19 12.2239 18.7761 12 18.5 12H17.5C17.2239 12 17 12.2239 17 12.5C17 12.7761 17.2239 13 17.5 13H18.5C18.7761 13 19 12.7761 19 12.5ZM15.5 8C15.7761 8 16 7.77614 16 7.5C16 7.22386 15.7761 7 15.5 7H14.5C14.2239 7 14 7.22386 14 7.5C14 7.77614 14.2239 8 14.5 8H15.5Z" fill="currentColor"></path></svg>
            </button>
        </div>
        <div class="flex justify-center gap-4 mb-6">
            <button id="generate-btn" class="styled-button btn-primary py-2 px-5 text-sm rounded-lg">
                Combinar
            </button>
            <button id="save-btn" class="hidden styled-button btn-secondary py-2 px-5 text-sm rounded-lg">
                Guardar
            </button>
        </div>
        
        <!-- Edit Section -->
        <div id="edit-section" class="hidden w-full mb-6">
            <div class="relative flex flex-col sm:flex-row gap-4">
                <input type="text" id="edit-prompt-input" class="w-full pl-3 py-2 text-sm bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Edita la imagen actual. Ej: Añade un cielo estrellado...">
                <button id="edit-btn" class="styled-button btn-primary py-2 px-5 text-sm rounded-lg whitespace-nowrap">
                    Editar
                </button>
            </div>
        </div>

        <!-- Inpaint Section -->
        <div id="inpaint-section" class="hidden w-full mb-6">
            <p class="text-indigo-300 mb-2 text-sm">Dibuja sobre la imagen para seleccionar un área, luego describe el cambio.</p>
            <div class="relative flex flex-col sm:flex-row gap-4">
                <input type="text" id="inpaint-prompt-input" class="w-full pl-3 py-2 text-sm bg-gray-800/50 border border-blue-500/50 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition placeholder-gray-500" placeholder="Ej: un gato negro sentado ahí...">
                <button id="inpaint-apply-btn" class="styled-button btn-secondary py-2 px-5 text-sm rounded-lg whitespace-nowrap">Aplicar Máscara</button>
            </div>
        </div>

        <!-- Result section with Carousel -->
        <div id="result-container" class="result-container relative w-full border rounded-lg p-2 mt-6 min-h-[300px] flex items-center justify-center shadow-inner">
             <button id="prev-btn" class="carousel-btn hidden absolute left-2 p-2 text-white"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
            <div id="carousel" class="carousel w-full h-full">
                <canvas id="mask-canvas" class="hidden"></canvas>
                <div id="carousel-track" class="carousel-track h-full">
                    <div id="placeholder-slide" class="carousel-slide">
                         <div id="placeholder" class="text-gray-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="currentColor" class="bi bi-image-alt mb-3 inline-block" viewBox="0 0 16 16"><path d="M7 2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0m4.225 4.053a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L.002 13V3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1.172a2.999 2.999 0 0 1-2.121-.879l-4.144-4.143a.5.5 0 0 0-.707 0L2.95 11.536l2.614-2.354a.5.5 0 0 0 .63-.062l2.66 1.772 3.71-3.71a.5.5 0 0 0 .093-.577z"/></svg>
                            <p>Tu imagen combinada aparecerá aquí.</p>
                        </div>
                    </div>
                </div>
            </div>
             <button id="next-btn" class="carousel-btn hidden absolute right-2 p-2 text-white"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></button>
            <div id="loader" class="hidden loader absolute"></div>
            <div id="error-message" class="hidden text-red-400 absolute"></div>
        </div>

    </div>

    <!-- Modals -->
    <div id="source-modal" class="modal-overlay hidden fixed inset-0 flex items-center justify-center">
        <div class="modal-content p-6 rounded-lg text-center">
            <h3 class="text-lg font-medium mb-4">Seleccionar Fuente</h3>
            <div class="flex gap-4">
                <button id="from-camera-btn" class="styled-button btn-primary flex-1 py-2 px-4 rounded-lg">Tomar Foto</button>
                <button id="from-file-btn" class="styled-button btn-secondary flex-1 py-2 px-4 rounded-lg">Elegir Archivo</button>
            </div>
            <button id="close-source-modal-btn" class="mt-4 text-gray-400 hover:text-white">Cancelar</button>
        </div>
    </div>
    <div id="camera-modal" class="modal-overlay hidden fixed inset-0 flex items-center justify-center p-4">
        <div class="modal-content p-4 rounded-lg text-center w-full max-w-lg">
            <video id="camera-view" class="w-full rounded-md mb-4" autoplay playsinline></video>
            <canvas id="camera-canvas" class="hidden"></canvas>
            <button id="capture-btn" class="styled-button btn-primary w-full py-2 px-4 rounded-lg mb-2">Capturar</button>
            <button id="close-camera-modal-btn" class="text-gray-400 hover:text-white">Cerrar</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const generateBtn = document.getElementById('generate-btn');
        const saveBtn = document.getElementById('save-btn');
        const promptInput = document.getElementById('prompt-input');
        const rewriteBtn = document.getElementById('rewrite-btn');
        const geminiIcon = document.getElementById('gemini-icon');
        const uploadContainer = document.getElementById('upload-container');
        
        const resultContainer = document.getElementById('result-container');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('error-message');
        const placeholderSlide = document.getElementById('placeholder-slide');

        // Edit Section
        const editSection = document.getElementById('edit-section');
        const editPromptInput = document.getElementById('edit-prompt-input');
        const editBtn = document.getElementById('edit-btn');

        // Inpaint Section
        const inpaintSection = document.getElementById('inpaint-section');
        const inpaintPromptInput = document.getElementById('inpaint-prompt-input');
        const inpaintApplyBtn = document.getElementById('inpaint-apply-btn');
        
        // Carousel Elements
        const carousel = document.getElementById('carousel');
        const carouselTrack = document.getElementById('carousel-track');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        // Modal Elements
        const sourceModal = document.getElementById('source-modal');
        const cameraModal = document.getElementById('camera-modal');
        const fromCameraBtn = document.getElementById('from-camera-btn');
        const fromFileBtn = document.getElementById('from-file-btn');
        const closeSourceModalBtn = document.getElementById('close-source-modal-btn');
        const closeCameraModalBtn = document.getElementById('close-camera-modal-btn');
        const captureBtn = document.getElementById('capture-btn');
        const video = document.getElementById('camera-view');
        const canvas = document.getElementById('camera-canvas');
        const maskCanvas = document.getElementById('mask-canvas');
        const maskCtx = maskCanvas.getContext('2d');



        // --- State Variables ---
        const NUM_SLOTS = 3;
        let uploadedImagesData = new Array(NUM_SLOTS).fill(null);
        let generatedImagesHistory = [];
        let currentImageIndex = 0;
        let currentSlotIndex = null;
        let cameraStream = null;
        let isMaskingActive = false;
        let isDrawing = false;

        // La API Key se gestiona de forma segura en el servidor.

        // --- Initialization ---
        function createUploadSlots() {
            for (let i = 0; i < NUM_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.className = 'upload-slot';
                slot.dataset.index = i;
                slot.innerHTML = `
                    <div class="upload-box relative flex flex-col items-center justify-center cursor-pointer rounded-lg w-20 h-20 md:w-28 md:h-28">
                        <svg class="icon h-6 w-6 mb-1 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>
                        <span class="text text-xs text-gray-400">Imagen ${i + 1}</span>
                        <img id="thumbnail-${i}" src="" class="hidden">
                    </div>
                    <input type="file" id="image-upload-${i}" class="hidden" accept="image/*">
                `;
                uploadContainer.appendChild(slot);

                slot.addEventListener('click', () => {
                    currentSlotIndex = i;
                    sourceModal.classList.remove('hidden');
                });
                
                const fileInput = slot.querySelector('input[type="file"]');
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => processImage(e.target.result, i);
                        reader.readAsDataURL(file);
                    }
                });
            }
        }
        createUploadSlots();


        // --- Modal & Camera Logic ---
        closeSourceModalBtn.addEventListener('click', () => sourceModal.classList.add('hidden'));
        
        fromFileBtn.addEventListener('click', () => {
            sourceModal.classList.add('hidden');
            document.getElementById(`image-upload-${currentSlotIndex}`).click();
        });

        fromCameraBtn.addEventListener('click', () => {
            sourceModal.classList.add('hidden');
            cameraModal.classList.remove('hidden');
            startCamera();
        });
        
        closeCameraModalBtn.addEventListener('click', stopCamera);

        captureBtn.addEventListener('click', () => {
            const context = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            if (video.style.transform === 'scaleX(-1)') {
                context.translate(canvas.width, 0);
                context.scale(-1, 1);
            }

            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/png');
            processImage(dataUrl, currentSlotIndex);
            stopCamera();
        });
        
        async function startCamera() {
            const rearCameraConstraints = { video: { facingMode: { ideal: 'environment' } } };
            const frontCameraConstraints = { video: { facingMode: 'user' } };
            
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia(rearCameraConstraints);
                video.style.transform = 'scaleX(1)';
            } catch (err) {
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia(frontCameraConstraints);
                    video.style.transform = 'scaleX(-1)';
                } catch (fallbackErr) {
                    showError("No se pudo acceder a la cámara. Revisa los permisos.");
                    stopCamera();
                    return;
                }
            }
            video.srcObject = cameraStream;
        }
        
        function stopCamera() {
            if (cameraStream) cameraStream.getTracks().forEach(track => track.stop());
            cameraModal.classList.add('hidden');
        }

        // --- Image Processing ---
        function processImage(dataUrl, index) {
            const thumbnail = document.getElementById(`thumbnail-${index}`);
            const uploadBox = thumbnail.closest('.upload-box');
            
            thumbnail.src = dataUrl;
            thumbnail.classList.remove('hidden');
            uploadBox.classList.add('has-image');
            
            const [header, base64Data] = dataUrl.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            uploadedImagesData[index] = { mimeType, data: base64Data };
            sourceModal.classList.add('hidden'); // Auto-close modal
        }


        // --- API & Generation Logic ---
        async function callApiWithBackoff(apiUrl, payload) {
            // Simplified for brevity, production code should have backoff
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error: ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
            }
            return await response.json();
        }

        async function handleImageGeneration(prompt, images, mask = null) {
            setLoadingState(true);
            deactivateMasking();
            try {
                // Ahora llamamos a nuestro propio backend
                const apiUrl = '/api/generate';
                const parts = [{ text: prompt }];
                images.forEach(img => parts.push({ inlineData: { mimeType: img.mimeType, data: img.data } }));
                if (mask) parts.push({ inlineData: { mimeType: mask.mimeType, data: mask.data } });
                const payload = { contents: [{ parts }] };

                const result = await callApiWithBackoff(apiUrl, payload);
                const candidate = result?.candidates?.[0];

                if (candidate && candidate.finishReason) {
                    if (candidate.finishReason === 'SAFETY') {
                        throw new Error("La combinación de imágenes fue bloqueada por motivos de seguridad.");
                    } else if (candidate.finishReason !== 'STOP') {
                        throw new Error(`Generación bloqueada. Razón: ${candidate.finishReason}`);
                    }
                }
                
                const imagePart = candidate?.content?.parts?.find(p => p.inlineData);
                if (imagePart && imagePart.inlineData.data) {
                    const mimeType = imagePart.inlineData.mimeType || 'image/png';
                    const imageUrl = `data:${mimeType};base64,${imagePart.inlineData.data}`;
                    addImageToCarousel(imageUrl);
                } else {
                    console.error("Invalid API Response:", JSON.stringify(result, null, 2));
                    throw new Error('La respuesta de la API no contiene datos de imagen válidos.');
                }
            } catch (error) {
                console.error('Failed to generate image:', error);
                showError(error.message || 'No se pudo generar la imagen.');
            } finally {
                setLoadingState(false);
            }
        }

        generateBtn.addEventListener('click', () => {
            const prompt = promptInput.value.trim();
            const validImages = uploadedImagesData.filter(img => img !== null);
            if (validImages.length === 0) return showError('Por favor, sube al menos una imagen.');
            if (!prompt) return showError('Por favor, describe cómo combinar las imágenes.');
            handleImageGeneration(prompt, validImages, null);
        });

        editBtn.addEventListener('click', () => {
            const prompt = editPromptInput.value.trim();
            if (!prompt) return showError('Por favor, describe cómo editar la imagen.');
            if (generatedImagesHistory.length === 0) return showError('No hay imagen para editar.');

            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            const imageData = { mimeType, data: base64Data };
            
            handleImageGeneration(prompt, [imageData], null);
        });
        
        rewriteBtn.addEventListener('click', async () => {
            const currentPrompt = promptInput.value;
            if (!currentPrompt) return;

            geminiIcon.classList.add('gemini-icon-spin');
            rewriteBtn.disabled = true;
            try {
                // Ahora llamamos a nuestro propio backend
                const apiUrl = '/api/generate';
                const payload = {
                    contents: [{
                        parts: [{ text: `Reformula y mejora el siguiente prompt para un modelo de generación de imágenes. Sé creativo y descriptivo. Devuelve solo el prompt mejorado, sin texto adicional. Prompt original: "${currentPrompt}"` }]
                    }]
                };
                const result = await callApiWithBackoff(apiUrl, payload);
                const newPrompt = result.candidates[0].content.parts[0].text.trim();
                promptInput.value = newPrompt;
            } catch (error) {
                console.error('Error reescribiendo el prompt:', error);
                showError('No se pudo mejorar el prompt.');
            } finally {
                geminiIcon.classList.remove('gemini-icon-spin');
                rewriteBtn.disabled = false;
            }
        });

        // --- Inpainting / Masking Logic ---
        inpaintApplyBtn.addEventListener('click', () => {
            const prompt = inpaintPromptInput.value.trim();
            if (!prompt) return showError('Por favor, describe el cambio para el área seleccionada.');
            if (generatedImagesHistory.length === 0) return showError('No hay imagen para editar.');

            // Get current image
            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            const imageData = { mimeType, data: base64Data };

            // Get mask
            const maskDataUrl = maskCanvas.toDataURL('image/png');
            const [maskHeader, maskBase64Data] = maskDataUrl.split(',');
            const maskMimeType = maskHeader.match(/:(.*?);/)[1];
            const maskData = { mimeType: maskMimeType, data: maskBase64Data };

            handleImageGeneration(prompt, [imageData], maskData);
        });

        function activateMasking() {
            isMaskingActive = true;
            maskCanvas.classList.remove('hidden');
            inpaintSection.classList.remove('hidden');
            editSection.classList.add('hidden'); // Hide regular edit

            const currentImageElement = carouselTrack.children[currentImageIndex].querySelector('img');
            if (currentImageElement) {
                maskCanvas.width = currentImageElement.clientWidth;
                maskCanvas.height = currentImageElement.clientHeight;
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            }
        }

        function deactivateMasking() {
            isMaskingActive = false;
            isDrawing = false;
            maskCanvas.classList.add('hidden');
            inpaintSection.classList.add('hidden');
            if (generatedImagesHistory.length > 0) editSection.classList.remove('hidden');
        }

        // --- Carousel Logic ---
        function addImageToCarousel(imageUrl) {
            generatedImagesHistory.push(imageUrl);
            
            if (placeholderSlide.parentElement) {
                carouselTrack.removeChild(placeholderSlide);
            }

            const slide = document.createElement('div');
            slide.className = 'carousel-slide';
            slide.innerHTML = `<img src="${imageUrl}" class="max-w-full max-h-[512px] h-full rounded-md object-contain">`;
            carouselTrack.appendChild(slide);

            currentImageIndex = generatedImagesHistory.length - 1;
            updateCarousel();
            editPromptInput.value = ''; // Clear edit prompt
        }

        function updateCarousel() {
            carouselTrack.style.transform = `translateX(-${currentImageIndex * 100}%)`;
            
            // Show/hide nav buttons
            prevBtn.classList.toggle('hidden', currentImageIndex === 0);
            nextBtn.classList.toggle('hidden', currentImageIndex === generatedImagesHistory.length - 1);
            
            // Show/hide save button and edit section
            const hasImages = generatedImagesHistory.length > 0;
            saveBtn.classList.toggle('hidden', !hasImages);
            editSection.classList.toggle('hidden', !hasImages);
            deactivateMasking(); // Deactivate mask when changing image
        }

        prevBtn.addEventListener('click', () => {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                updateCarousel();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentImageIndex < generatedImagesHistory.length - 1) {
                currentImageIndex++;
                updateCarousel();
            }
        });
        
        let touchstartX = 0;
        let touchendX = 0;

        carousel.addEventListener('touchstart', e => { touchstartX = e.changedTouches[0].screenX }, { passive: true });
        carousel.addEventListener('touchend', e => {
            touchendX = e.changedTouches[0].screenX;
            if (touchendX < touchstartX - 50) nextBtn.click();
            if (touchendX > touchstartX + 50) prevBtn.click();
        });

        // --- Mask Drawing Events ---
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = evt.clientX || evt.touches[0].clientX;
            const clientY = evt.clientY || evt.touches[0].clientY;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function drawOnMask(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const pos = getMousePos(maskCanvas, e);
            maskCtx.lineTo(pos.x, pos.y);
            maskCtx.stroke();
        }

        maskCanvas.addEventListener('mousedown', (e) => {
            if (!isMaskingActive) return;
            isDrawing = true;
            const pos = getMousePos(maskCanvas, e);
            maskCtx.beginPath();
            maskCtx.moveTo(pos.x, pos.y);
            maskCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            maskCtx.lineWidth = 20;
            maskCtx.lineCap = 'round';
            maskCtx.lineJoin = 'round';
        });
        maskCanvas.addEventListener('mouseup', () => { isDrawing = false; });
        maskCanvas.addEventListener('mouseout', () => { isDrawing = false; });
        maskCanvas.addEventListener('mousemove', drawOnMask);

        // --- UI Helper Functions ---
        saveBtn.addEventListener('click', () => {
            if (generatedImagesHistory.length > 0) {
                 const link = document.createElement('a');
                 link.href = generatedImagesHistory[currentImageIndex];
                 link.download = `imagen-generada-${currentImageIndex + 1}.png`;
                 link.click();
            }
        });

        function setLoadingState(isLoading) {
            hideError();
            loader.classList.toggle('hidden', !isLoading);
            generateBtn.disabled = isLoading;
            editBtn.disabled = isLoading;
            inpaintApplyBtn.disabled = isLoading;
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideError() {
            errorMessage.classList.add('hidden');
        }

        // Rename edit button and add listener for masking
        editBtn.textContent = 'Editar Área';
        editBtn.addEventListener('click', activateMasking);

    </script>
</body>
</html>
