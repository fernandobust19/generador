<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combinador de Im√°genes con IA</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü™Ñ</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(-45deg, #0d0221, #0c164f, #1e1b4b, #4338ca);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .styled-button {
            transition: all 0.3s ease-in-out;
            border: 2px solid;
            font-weight: 600;
            background-color: transparent;
        }
        .styled-button:hover:not(:disabled) {
            transform: scale(1.05) translateY(-2px);
            color: #ffffff;
        }
        .styled-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            border-color: #6366f1; /* indigo-500 */
            color: #818cf8; /* indigo-400 */
            box-shadow: 0 0 8px rgba(99, 102, 241, 0.4);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #6366f1;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.7);
        }
         .btn-secondary {
            border-color: #3b82f6; /* blue-500 */
            color: #60a5fa; /* blue-400 */
             box-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
        }

        .loader {
            border: 4px solid #374151;
            border-top: 4px solid #6366f1; /* indigo-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-box {
            background-color: rgba(17, 24, 39, 0.5);
            border: 2px dashed #4f46e5; /* indigo-600 */
            transition: all 0.3s ease;
            box-shadow: 0 0 8px rgba(79, 70, 229, 0.3);
        }
        .upload-box:hover {
            border-color: #818cf8; /* indigo-400 */
            box-shadow: 0 0 12px rgba(129, 140, 248, 0.5);
            transform: scale(1.05);
        }
        .upload-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 0.5rem;
        }
        .upload-box .icon, .upload-box .text { z-index: 5; }
        .upload-box.has-image .icon, .upload-box.has-image .text { opacity: 0; }
        
        .result-container {
             background-color: rgba(17, 24, 39, 0.5);
             border-color: rgba(99, 102, 241, 0.4);
             box-shadow: 0 0 15px rgba(99, 102, 241, 0.2);
        }

        .gemini-icon-spin {
            animation: spin 1s linear infinite;
        }
        
        .modal-overlay {
            background-color: rgba(0,0,0,0.7);
            z-index: 999;
        }
        .modal-content {
            background-color: #1e1b4b;
            box-shadow: 0 0 25px rgba(99, 102, 241, 0.5);
        }
        #camera-view video {
            transform: scaleX(-1);
        }

        #mask-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.2); /* Fondo rojo semitransparente para visualizaci√≥n */
            cursor: crosshair;
            pointer-events: auto;
            z-index: 5;
        }

        .drawing-prompt-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(17, 24, 39, 0.95);
            border: 2px solid #6366f1;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            max-width: 400px;
            width: 90%;
            backdrop-filter: blur(10px);
        }

        #floating-image-container {
            position: absolute;
            touch-action: none; /* Required for interact.js */
            user-select: none;
            box-sizing: border-box;
            border: 2px solid rgba(99, 102, 241, 0.7); /* Dashed border to show it's an element */
        }
        #floating-image-container img {
            width: 100%;
            height: 100%;
            pointer-events: none; /* Make sure clicks go through the image to the container for dragging */
        }
        .interaction-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #6366f1;
            border: 2px solid white;
            border-radius: 50%;
            z-index: 10;
        }
        #resize-handle {
            bottom: -10px;
            right: -10px;
            cursor: se-resize;
        }
        #rotate-handle {
            top: -10px;
            right: -10px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>') 16 16, auto;
        }
        /* Carousel Styles */
        .carousel {
            overflow-x: scroll;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
        }
        .carousel::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }
        .carousel-track {
            display: flex;
            transition: transform 0.3s ease-in-out;
        }
        .carousel-slide {
            flex: 0 0 100%;
            width: 100%;
            scroll-snap-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .carousel-btn {
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0,0,0,0.4);
            border-radius: 50%;
            z-index: 10;
        }
        .carousel-btn:hover {
             background-color: rgba(0,0,0,0.7);
        }
    </style>
</head>
<body class="text-white flex items-center justify-center min-h-screen p-4">
    <div class="container mx-auto max-w-3xl text-center">
        
        <h1 class="text-2xl md:text-3xl font-bold mb-2 bg-gradient-to-r from-blue-400 to-indigo-500 text-transparent bg-clip-text">
            Combinador de Im√°genes IA
        </h1>
        <p class="text-gray-400 text-sm mb-8">
            Sube hasta 3 im√°genes y describe c√≥mo combinarlas.
        </p>

        <!-- Image upload section -->
        <div id="upload-container" class="flex justify-center items-center gap-2 sm:gap-4 mb-6">
             <!-- Slots are generated by JS now -->
        </div>

        <!-- Input section -->
        <div class="flex items-center gap-2 w-full mb-6">
            <div class="relative flex-grow">
                <input type="text" id="prompt-input" class="w-full pl-3 pr-10 py-1 text-xs bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Describe tu idea...">
                <button id="rewrite-btn" class="absolute inset-y-0 right-0 flex items-center pr-3 group" title="Generar idea de prompt con IA">
                    <svg id="gemini-icon" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 text-gray-400 group-hover:text-indigo-400 transition" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M15.5 2.5a.5.5 0 00-.5-.5h-10a.5.5 0 00-.5.5v10a.5.5 0 00.5.5h10a.5.5 0 00.5-.5v-10zM5 4a1 1 0 00-1 1v10a1 1 0 001 1h10a1 1 0 001-1V5a1 1 0 00-1-1H5z" clip-rule="evenodd" />
                        <path d="M8 6a1 1 0 100 2 1 1 0 000-2zM6 10a1 1 0 112 0 1 1 0 01-2 0zm4 0a1 1 0 112 0 1 1 0 01-2 0zm2 4a1 1 0 100-2 1 1 0 000 2zm-4-4a1 1 0 112 0 1 1 0 01-2 0z" />
                    </svg>
                </button>
            </div>
            <button id="generate-btn" class="styled-button btn-primary py-1 px-3 text-xs rounded-md whitespace-nowrap">
                Combinar
            </button>
        </div>
        
        <!-- Edit Section -->
        <div id="edit-section" class="hidden w-full mb-6">
            <div class="relative flex flex-col sm:flex-row gap-2">
                <input type="text" id="edit-prompt-input" class="w-full pl-3 py-1 text-xs bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Edita la imagen actual. Ej: A√±ade un cielo estrellado...">
                <button id="edit-btn" class="styled-button btn-primary py-1 px-4 text-xs rounded-lg whitespace-nowrap">Editar</button> <!-- For general edits -->
                <button id="inpaint-cancel-btn" class="hidden styled-button btn-primary py-1 px-4 text-xs rounded-lg whitespace-nowrap bg-gray-600 border-gray-500 text-gray-300 hover:bg-gray-700">Cancelar</button>
            </div>
        </div>

        <!-- Overlay Section -->
        <div id="overlay-section" class="hidden w-full mb-6 p-3 border border-indigo-500/30 rounded-lg bg-gray-900/20">
             <p class="text-indigo-300 mb-2 text-xs text-left">A√±ade una imagen superpuesta. Arr√°strala, redimensi√≥nala y r√≥tala sobre la imagen de fondo.</p>
            <div class="flex flex-col sm:flex-row items-center gap-2">
                <button id="upload-overlay-btn" class="styled-button btn-secondary py-1 px-3 text-xs rounded-md whitespace-nowrap">Cargar Imagen Flotante</button>
                <input type="file" id="overlay-image-upload" class="hidden" accept="image/*">
                <div class="relative flex-grow w-full sm:w-auto">
                    <input type="text" id="overlay-prompt-input" class="w-full pl-3 pr-10 py-1 text-xs bg-gray-800/50 border border-indigo-500/50 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition placeholder-gray-500" placeholder="Ej: un fantasma transparente sobre el bosque...">
                </div>
                <button id="implement-overlay-btn" class="styled-button btn-primary py-1 px-3 text-xs rounded-md whitespace-nowrap flex items-center gap-1.5">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor"><path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zm0 4a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zm0 4a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1z" /></svg>
                    <span>Implementar</span>
                </button>
            </div>
        </div>

        <!-- Save Actions Section -->
        <div id="save-actions" class="hidden w-full flex justify-between items-center gap-2 mb-4">
            <div class="flex items-center gap-1 p-1 border border-indigo-500/50 rounded-lg bg-gray-800/30">
                <button id="tool-pencil" class="tool-btn p-1 rounded-md hover:bg-indigo-500/50" title="Dibujo libre">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></svg>
                </button>
            </div>
            <button id="save-btn" class="styled-button btn-secondary py-1 px-3 text-xs rounded-md whitespace-nowrap bg-blue-500 text-white hover:bg-blue-600">Guardar</button>
            <button id="save-album-btn" class="styled-button btn-primary py-1 px-3 text-xs rounded-md whitespace-nowrap bg-indigo-500 text-white hover:bg-indigo-600">Guardar √Ålbum</button>
        </div>

        <!-- Result section with Carousel -->
        <div id="result-container" class="result-container relative w-full border rounded-lg p-2 min-h-[300px] flex items-center justify-center shadow-inner">
             <button id="prev-btn" class="carousel-btn hidden absolute left-2 p-2 text-white"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
            <div id="carousel" class="carousel w-full h-full">
                <canvas id="mask-canvas" class="hidden"></canvas>
                <div id="carousel-track" class="carousel-track h-full">
                    <div id="placeholder-slide" class="carousel-slide">
                         <div id="placeholder" class="text-gray-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="currentColor" class="bi bi-image-alt mb-3 inline-block" viewBox="0 0 16 16"><path d="M7 2.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0m4.225 4.053a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L.002 13V3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1.172a2.999 2.999 0 0 1-2.121-.879l-4.144-4.143a.5.5 0 0 0-.707 0L2.95 11.536l2.614-2.354a.5.5 0 0 0 .63-.062l2.66 1.772 3.71-3.71a.5.5 0 0 0 .093-.577z"/></svg>
                            <p>Tu imagen combinada aparecer√° aqu√≠.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div id="floating-image-container" class="hidden">
                <img id="floating-image" src="" alt="Imagen flotante">
                <div id="resize-handle" class="interaction-handle"></div>
                <div id="rotate-handle" class="interaction-handle"></div>
            </div>
             <button id="next-btn" class="carousel-btn hidden absolute right-2 p-2 text-white"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></button>
            <div id="loader" class="hidden loader absolute"></div>
            <div id="error-message" class="hidden text-red-400 absolute"></div>
        </div>

    </div>

    <!-- Modals -->
    <div id="source-modal" class="modal-overlay hidden fixed inset-0 flex items-center justify-center">
        <div class="modal-content p-6 rounded-lg text-center">
            <h3 class="text-lg font-medium mb-4">Seleccionar Fuente</h3>
            <div class="flex gap-4">
                <button id="from-camera-btn" class="styled-button btn-primary flex-1 py-2 px-4 rounded-lg">Tomar Foto</button>
                <button id="from-file-btn" class="styled-button btn-secondary flex-1 py-2 px-4 rounded-lg">Elegir Archivo</button>
            </div>
            <button id="close-source-modal-btn" class="mt-4 text-gray-400 hover:text-white">Cancelar</button>
        </div>
    </div>
    <div id="camera-modal" class="modal-overlay hidden fixed inset-0 flex items-center justify-center p-4">
        <div class="modal-content p-4 rounded-lg text-center w-full max-w-lg">
            <video id="camera-view" class="w-full rounded-md mb-4" autoplay playsinline></video>
            <canvas id="camera-canvas" class="hidden"></canvas>
            <button id="capture-btn" class="styled-button btn-primary w-full py-2 px-4 rounded-lg mb-2">Capturar</button>
            <button id="close-camera-modal-btn" class="text-gray-400 hover:text-white">Cerrar</button>
        </div>
    </div>

    <!-- Drawing Area Prompt Modal -->
    <div id="drawing-prompt-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 border border-indigo-500">
            <h3 class="text-lg font-semibold mb-4 text-center text-white">¬øQu√© cambio quieres hacer?</h3>
            <textarea id="drawing-prompt-textarea" 
                     class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white resize-none focus:border-indigo-400 focus:outline-none" 
                     rows="3" 
                     placeholder="Describe el cambio que quieres aplicar en esta zona espec√≠fica..."></textarea>
            <div class="flex gap-3 mt-4">
                <button id="drawing-prompt-cancel" class="flex-1 btn-secondary styled-button px-4 py-2 rounded-lg">Cancelar</button>
                <button id="drawing-prompt-apply" class="flex-1 btn-primary styled-button px-4 py-2 rounded-lg">Aplicar Cambio</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const generateBtn = document.getElementById('generate-btn');
        const saveActions = document.getElementById('save-actions');
        const saveBtn = document.getElementById('save-btn'); // Bot√≥n individual
        const promptInput = document.getElementById('prompt-input');
        const rewriteBtn = document.getElementById('rewrite-btn');
        const geminiIcon = document.getElementById('gemini-icon');
        const uploadContainer = document.getElementById('upload-container');
        
        const resultContainer = document.getElementById('result-container');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('error-message');
        const saveAlbumBtn = document.getElementById('save-album-btn');
        const placeholderSlide = document.getElementById('placeholder-slide');

        // Edit Section
        const editSection = document.getElementById('edit-section');
        const editPromptInput = document.getElementById('edit-prompt-input');
        const editBtn = document.getElementById('edit-btn');
        const inpaintCancelBtn = document.getElementById('inpaint-cancel-btn');
        
        // Drawing Tools
        const toolPencil = document.getElementById('tool-pencil');
        
        // Overlay Section
        const overlaySection = document.getElementById('overlay-section');
        const uploadOverlayBtn = document.getElementById('upload-overlay-btn');
        const overlayImageUpload = document.getElementById('overlay-image-upload');
        const overlayPromptInput = document.getElementById('overlay-prompt-input');
        const implementOverlayBtn = document.getElementById('implement-overlay-btn');
        const floatingImageContainer = document.getElementById('floating-image-container');
        const floatingImage = document.getElementById('floating-image');

        // Carousel Elements
        const carousel = document.getElementById('carousel');
        const carouselTrack = document.getElementById('carousel-track');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        // Modal Elements
        const sourceModal = document.getElementById('source-modal');
        const cameraModal = document.getElementById('camera-modal');
        const drawingPromptModal = document.getElementById('drawing-prompt-modal');
        const fromCameraBtn = document.getElementById('from-camera-btn');
        const fromFileBtn = document.getElementById('from-file-btn');
        const closeSourceModalBtn = document.getElementById('close-source-modal-btn');
        const closeCameraModalBtn = document.getElementById('close-camera-modal-btn');
        const captureBtn = document.getElementById('capture-btn');
        const video = document.getElementById('camera-view');
        const canvas = document.getElementById('camera-canvas');
        const maskCanvas = document.getElementById('mask-canvas');
        const maskCtx = maskCanvas.getContext('2d');
        

        // --- State Variables ---
        const NUM_SLOTS = 3;
        let uploadedImagesData = new Array(NUM_SLOTS).fill(null);
        let generatedImagesHistory = [];
        let currentImageIndex = 0;
        let currentSlotIndex = null;
        let cameraStream = null;
        let isDrawing = false;
        let overlayImageData = null;

        // Drawing/Inpainting State
        let isDrawingMode = false;
        let lastPos = { x: 0, y: 0 };

        // La API Key se gestiona de forma segura en el servidor.

        // --- Initialization ---
        function createUploadSlots() {
            for (let i = 0; i < NUM_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.className = 'upload-slot';
                slot.dataset.index = i;
                slot.innerHTML = `
                    <div class="upload-box relative flex flex-col items-center justify-center cursor-pointer rounded-lg w-20 h-20 md:w-28 md:h-28">
                        <svg class="icon h-6 w-6 mb-1 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>
                        <span class="text text-xs text-gray-400">Imagen ${i + 1}</span>
                        <img id="thumbnail-${i}" src="" class="hidden">
                    </div>
                    <input type="file" id="image-upload-${i}" class="hidden" accept="image/*">
                `;
                uploadContainer.appendChild(slot);

                slot.addEventListener('click', () => {
                    currentSlotIndex = i;
                    sourceModal.classList.remove('hidden');
                });
                
                const fileInput = slot.querySelector('input[type="file"]');
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => processImage(e.target.result, i);
                        reader.readAsDataURL(file);
                    }
                });
            }
        }
        createUploadSlots();


        // --- Modal & Camera Logic ---
        closeSourceModalBtn.addEventListener('click', () => sourceModal.classList.add('hidden'));
        
        fromFileBtn.addEventListener('click', () => {
            sourceModal.classList.add('hidden');
            document.getElementById(`image-upload-${currentSlotIndex}`).click();
        });

        fromCameraBtn.addEventListener('click', () => {
            sourceModal.classList.add('hidden');
            cameraModal.classList.remove('hidden');
            startCamera();
        });
        
        closeCameraModalBtn.addEventListener('click', stopCamera);

        captureBtn.addEventListener('click', () => {
            const context = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            if (video.style.transform === 'scaleX(-1)') {
                context.translate(canvas.width, 0);
                context.scale(-1, 1);
            }

            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/png');
            processImage(dataUrl, currentSlotIndex);
            stopCamera();
        });
        
        async function startCamera() {
            const rearCameraConstraints = { video: { facingMode: { ideal: 'environment' } } };
            const frontCameraConstraints = { video: { facingMode: 'user' } };
            
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia(rearCameraConstraints);
                video.style.transform = 'scaleX(1)';
            } catch (err) {
                try {
                    cameraStream = await navigator.mediaDevices.getUserMedia(frontCameraConstraints);
                    video.style.transform = 'scaleX(-1)';
                } catch (fallbackErr) {
                    showError("No se pudo acceder a la c√°mara. Revisa los permisos.");
                    stopCamera();
                    return;
                }
            }
            video.srcObject = cameraStream;
        }
        
        function stopCamera() {
            if (cameraStream) cameraStream.getTracks().forEach(track => track.stop());
            cameraModal.classList.add('hidden');
        }

        // --- Image Processing ---
        function processImage(dataUrl, index) {
            const thumbnail = document.getElementById(`thumbnail-${index}`);
            const uploadBox = thumbnail.closest('.upload-box');
            
            thumbnail.src = dataUrl;
            thumbnail.classList.remove('hidden');
            uploadBox.classList.add('has-image');
            
            const [header, base64Data] = dataUrl.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            uploadedImagesData[index] = { mimeType, data: base64Data };
            sourceModal.classList.add('hidden'); // Auto-close modal
        }

        // --- Overlay Image Logic ---
        uploadOverlayBtn.addEventListener('click', () => overlayImageUpload.click());

        overlayImageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Reset previous transformations before showing the new image
                    floatingImageContainer.style.transform = '';
                    floatingImageContainer.style.width = '150px'; // Set initial small size
                    floatingImageContainer.style.height = ''; // Let height be auto
                    floatingImageContainer.removeAttribute('data-x');
                    floatingImageContainer.removeAttribute('data-y');
                    floatingImageContainer.removeAttribute('data-rotate');
                    floatingImageContainer.removeAttribute('data-scale');

                    floatingImage.src = e.target.result;
                    floatingImageContainer.classList.remove('hidden');

                    // Center the new small image
                    const parentRect = resultContainer.getBoundingClientRect();
                    const initialX = (parentRect.width - 150) / 2;
                    const initialY = (parentRect.height - 150) / 2; // Approximate height
                    floatingImageContainer.style.transform = `translate(${initialX}px, ${initialY}px)`;
                    floatingImageContainer.setAttribute('data-x', initialX);
                    floatingImageContainer.setAttribute('data-y', initialY);

                    const [header, base64Data] = e.target.result.split(',');
                    overlayImageData = { mimeType: header.match(/:(.*?);/)[1], data: base64Data };
                };
                reader.readAsDataURL(file);
            }
        });

        // --- API & Generation Logic ---
        async function callApiWithBackoff(apiUrl, payload) {
            // Simplified for brevity, production code should have backoff
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error: ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);
            }
            return await response.json();
        }

        async function handleImageGeneration(prompt, images, { mask = null, overlay = null } = {}) {
            setLoadingState(true);
            try {
                // Ahora llamamos a nuestro propio backend
                const apiUrl = '/api/generate';

                // Si hay una imagen superpuesta, el prompt se construye de forma especial
                if (overlay && overlay.image) {
                    const bgImageElement = carouselTrack.children[currentImageIndex].querySelector('img');
                    const bgWidth = bgImageElement.clientWidth;
                    const bgHeight = bgImageElement.clientHeight;

                    prompt = `Toma la primera imagen como fondo (lienzo). El tama√±o del lienzo es ${bgWidth}px de ancho por ${bgHeight}px de alto.
                    Ahora, superp√≥n la segunda imagen (la imagen flotante) sobre este lienzo.
                    - Posici√≥n de la imagen flotante (coordenadas top, left desde la esquina superior izquierda del lienzo): ${Math.round(overlay.y)}px, ${Math.round(overlay.x)}px.
                    - Tama√±o de la imagen flotante: ${Math.round(overlay.width)}px de ancho por ${Math.round(overlay.height)}px de alto.
                    - Rotaci√≥n de la imagen flotante: ${Math.round(overlay.rotation)} grados.
                    Finalmente, integra la imagen flotante en el fondo aplicando esta instrucci√≥n creativa: "${prompt}". La segunda imagen es la que se debe transformar y colocar; la primera es solo el lienzo.`;
                    
                    // El orden es importante: primero el fondo, luego la imagen a superponer
                    images.push(overlay.image);
                }


                const parts = [{ text: prompt }];
                images.forEach(img => parts.push({ inlineData: { mimeType: img.mimeType, data: img.data } }));
                if (mask) parts.push({ inlineData: { mimeType: mask.mimeType, data: mask.data } });
                const payload = { contents: [{ parts }] };

                const result = await callApiWithBackoff(apiUrl, payload);
                const candidate = result?.candidates?.[0];

                if (candidate && candidate.finishReason) {
                    if (candidate.finishReason === 'SAFETY') {
                        throw new Error("La combinaci√≥n de im√°genes fue bloqueada por motivos de seguridad.");
                    } else if (candidate.finishReason !== 'STOP') {
                        throw new Error(`Generaci√≥n bloqueada. Raz√≥n: ${candidate.finishReason}`);
                    }
                }
                
                const imagePart = candidate?.content?.parts?.find(p => p.inlineData);
                if (imagePart && imagePart.inlineData.data) {
                    const mimeType = imagePart.inlineData.mimeType || 'image/png';
                    const imageUrl = `data:${mimeType};base64,${imagePart.inlineData.data}`;
                    addImageToCarousel(imageUrl);
                } else {
                    console.error("Invalid API Response:", JSON.stringify(result, null, 2));
                    throw new Error('La respuesta de la API no contiene datos de imagen v√°lidos.');
                }
            } catch (error) {
                console.error('Failed to generate image:', error);
                showError(error.message || 'No se pudo generar la imagen.');
            } finally {
                setLoadingState(false);
            }
        }

        generateBtn.addEventListener('click', () => {
            const prompt = promptInput.value.trim();
            const validImages = uploadedImagesData.filter(img => img !== null);
            if (validImages.length === 0) return showError('Por favor, sube al menos una imagen.');
            if (!prompt) return showError('Por favor, describe c√≥mo combinar las im√°genes.');
            handleImageGeneration(prompt, validImages);
        });

        editBtn.addEventListener('click', () => {
            const prompt = editPromptInput.value.trim();
            if (!prompt) return showError('Por favor, describe c√≥mo editar la imagen.');
            if (generatedImagesHistory.length === 0) return showError('No hay imagen para editar.');

            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const mimeType = header.match(/:(.*?);/)[1];
            const imageData = { mimeType, data: base64Data };
            
            handleImageGeneration(prompt, [imageData]);
        }); // Fin de editBtn listener
        
        rewriteBtn.addEventListener('click', async () => {
            const validImages = uploadedImagesData.filter(img => img !== null);
            if (validImages.length === 0) {
                return showError('Sube al menos una imagen para generar una idea.');
            }

            geminiIcon.classList.add('gemini-icon-spin');
            rewriteBtn.disabled = true;
            try {
                // Ahora llamamos a nuestro propio backend
                const apiUrl = '/api/generate';
                
                const parts = [{ text: "Observa las siguientes im√°genes. Genera un prompt creativo y descriptivo para combinarlas en una sola imagen. Devuelve √∫nicamente el texto del prompt, sin explicaciones ni introducciones." }];
                validImages.forEach(img => parts.push({ inlineData: { mimeType: img.mimeType, data: img.data } }));

                const payload = {
                    contents: [{
                        parts: parts
                    }]
                };
                const result = await callApiWithBackoff(apiUrl, payload);
                const newPrompt = result.candidates[0].content.parts[0].text.trim();
                promptInput.value = newPrompt.replace(/\"/g, ''); // Limpia comillas
            } catch (error) {
                console.error('Error reescribiendo el prompt:', error);
                showError('No se pudo mejorar el prompt.');
            } finally {
                geminiIcon.classList.remove('gemini-icon-spin');
                rewriteBtn.disabled = false;
            }
        });

        implementOverlayBtn.addEventListener('click', async () => {
            const prompt = overlayPromptInput.value.trim();
            if (!prompt) return showError('Describe c√≥mo implementar la imagen flotante.');
            if (!overlayImageData) return showError('Carga una imagen flotante primero.');
            if (generatedImagesHistory.length === 0) return showError('No hay imagen de fondo para editar.');

            // Get base image
            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const baseImage = { mimeType: header.match(/:(.*?);/)[1], data: base64Data };

            // Get overlay image and its transformations
            const overlay = {
                image: overlayImageData,
                x: parseFloat(floatingImageContainer.dataset.x || 0),
                y: parseFloat(floatingImageContainer.dataset.y || 0),
                width: floatingImageContainer.clientWidth,
                height: floatingImageContainer.clientHeight,
                rotation: parseFloat(floatingImageContainer.dataset.rotate || 0),
                scale: parseFloat(floatingImageContainer.dataset.scale || 1)
            };
            
            await handleImageGeneration(prompt, [baseImage], { overlay });

            // Hide and reset the floating image after generation is complete
            floatingImageContainer.classList.add('hidden');
            floatingImage.src = '';
            overlayImageData = null;
            overlayPromptInput.value = ''; // Borra el texto del prompt
            floatingImageContainer.style.transform = '';
            floatingImageContainer.removeAttribute('data-x');
            floatingImageContainer.removeAttribute('data-y');
            floatingImageContainer.removeAttribute('data-rotate');
            floatingImageContainer.removeAttribute('data-scale');
        });

        // --- Carousel Logic ---
        function addImageToCarousel(imageUrl) {
            generatedImagesHistory.push(imageUrl);
            
            if (placeholderSlide.parentElement) {
                carouselTrack.removeChild(placeholderSlide);
            }

            const slide = document.createElement('div');
            slide.className = 'carousel-slide';
            slide.innerHTML = `<img src="${imageUrl}" class="max-w-full max-h-[512px] h-full rounded-md object-contain">`;
            carouselTrack.appendChild(slide);

            currentImageIndex = generatedImagesHistory.length - 1;
            updateCarousel();
            editPromptInput.value = ''; // Clear edit prompt
        }

        function updateCarousel() {
            carouselTrack.style.transform = `translateX(-${currentImageIndex * 100}%)`;
            
            // Show/hide nav buttons
            prevBtn.classList.toggle('hidden', currentImageIndex === 0);
            nextBtn.classList.toggle('hidden', currentImageIndex === generatedImagesHistory.length - 1);
            
            // Show/hide save buttons and edit section
            const hasImages = generatedImagesHistory.length > 0;
            saveActions.classList.toggle('hidden', !hasImages);
            editSection.classList.toggle('hidden', !hasImages && !isDrawingMode);
            overlaySection.classList.toggle('hidden', !hasImages && !isDrawingMode);
            saveAlbumBtn.classList.toggle('hidden', generatedImagesHistory.length < 2);
            
            if (isDrawingMode || isDrawing) {
                deactivateDrawingMode();
            }
        }

        saveAlbumBtn.addEventListener('click', async () => {
            if (generatedImagesHistory.length < 2) return;

            setLoadingState(true); // Muestra el loader
            try {
                const zip = new JSZip();
                generatedImagesHistory.forEach((dataUrl, index) => {
                    const base64Data = dataUrl.split(',')[1];
                    zip.file(`imagen-generada-${index + 1}.png`, base64Data, { base64: true });
                });

                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = 'album-imagenes-generadas.zip';
                link.click();
                URL.revokeObjectURL(link.href);
            } catch (error) {
                console.error("Error creando el archivo zip:", error);
                showError("No se pudo crear el √°lbum.");
            } finally {
                setLoadingState(false); // Oculta el loader
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                updateCarousel();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentImageIndex < generatedImagesHistory.length - 1) {
                currentImageIndex++;
                updateCarousel();
            }
        });
        
        let touchstartX = 0;
        let touchendX = 0;

        carousel.addEventListener('touchstart', e => { touchstartX = e.changedTouches[0].screenX }, { passive: true });
        carousel.addEventListener('touchend', e => {
            touchendX = e.changedTouches[0].screenX;
            if (touchendX < touchstartX - 50) nextBtn.click();
            if (touchendX > touchstartX + 50) prevBtn.click();
        });

        // --- UI Helper Functions ---
        saveBtn.addEventListener('click', () => {
            if (generatedImagesHistory.length > 0) {
                 const link = document.createElement('a');
                 link.href = generatedImagesHistory[currentImageIndex];
                 link.download = `imagen-generada-${currentImageIndex + 1}.png`;
                 link.click();
            }
        });

        function setLoadingState(isLoading) {
            hideError();
            loader.classList.toggle('hidden', !isLoading);
            if(generateBtn) generateBtn.disabled = isLoading;
            editBtn.disabled = isLoading;
            implementOverlayBtn.disabled = isLoading;
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideError() {
            errorMessage.classList.add('hidden');
        }

        // Add listeners for drawing tools
        toolPencil.addEventListener('click', activateDrawingMode);
        inpaintCancelBtn.addEventListener('click', deactivateDrawingMode);
        // Drawing mode functions
        function activateDrawingMode() {
            if (generatedImagesHistory.length === 0) {
                showError('Primero genera una imagen para poder dibujar sobre ella.');
                return;
            }
            
            isDrawingMode = true;
            editBtn.classList.add('hidden'); // Hide general edit button
            inpaintCancelBtn.classList.remove('hidden'); // Show cancel button
            overlaySection.classList.add('hidden');
            
            // Show helper message
            showError(`‚úèÔ∏è Modo L√°piz Activo. Dibuja en la imagen y describe el cambio.`);
            setTimeout(() => hideError(), 5000);
            
            // Highlight the active tool
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('bg-indigo-500'));
            document.getElementById('tool-pencil').classList.add('bg-indigo-500');
            
            // Set cursor for the result container
            resultContainer.style.cursor = 'crosshair';
            
            // Make sure the result container can receive mouse events
            resultContainer.style.pointerEvents = 'auto';
            setupMaskCanvas();
        }

        function deactivateDrawingMode() {
            isDrawingMode = false;
            isDrawing = false;
            editBtn.classList.remove('hidden');
            inpaintCancelBtn.classList.add('hidden');
            if (generatedImagesHistory.length > 0) overlaySection.classList.remove('hidden');

            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('bg-indigo-500'));
            resultContainer.style.cursor = 'default';
            resultContainer.style.pointerEvents = 'auto';
            
            // Clear and hide mask canvas
            if (!maskCanvas.classList.contains('hidden')) {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                maskCanvas.classList.add('hidden');
            }
            
            // Show message
            hideError();
            showError('‚úÖ Modo dibujo desactivado.');
            setTimeout(() => hideError(), 3000);
        }

        function showDrawingPromptPopup() {
            drawingPromptModal.classList.remove('hidden');
            document.getElementById('drawing-prompt-textarea').focus();
        }

        document.getElementById('drawing-prompt-apply').addEventListener('click', async () => {
            const prompt = document.getElementById('drawing-prompt-textarea').value.trim();
            if (!prompt) {
                showError('Por favor describe el cambio que quieres hacer.');
                return;
            }
            drawingPromptModal.classList.add('hidden');
            await applyDrawingChange(prompt);
        });

        document.getElementById('drawing-prompt-cancel').addEventListener('click', () => {
            drawingPromptModal.classList.add('hidden');
            // If the user cancels pencil drawing, clear the mask to avoid confusion
            if (!maskCanvas.classList.contains('hidden')) {
                maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            }
        });

        drawingPromptModal.addEventListener('click', (e) => {
            if (e.target === drawingPromptModal) {
                document.getElementById('drawing-prompt-cancel').click();
            }
        });
        async function applyDrawingChange(prompt) {
            let maskData;

            const maskDataUrl = maskCanvas.toDataURL('image/png');
            const [maskHeader, maskBase64Data] = maskDataUrl.split(',');
            maskData = { mimeType: maskHeader.match(/:(.*?);/)[1], data: maskBase64Data };
            
            await performInpaint(prompt, maskData);
        }

        async function performInpaint(prompt, maskData) {
            const currentImage = generatedImagesHistory[currentImageIndex];
            const [header, base64Data] = currentImage.split(',');
            const imageData = { mimeType: header.match(/:(.*?);/)[1], data: base64Data };
            
            await handleImageGeneration(prompt, [imageData], { mask: maskData });
            
            deactivateDrawingMode();
        }

        function setupMaskCanvas() {
            const currentImageElement = carouselTrack.children[currentImageIndex]?.querySelector('img');
            if (!currentImageElement) return;

            const rect = currentImageElement.getBoundingClientRect();
            const containerRect = resultContainer.getBoundingClientRect();

            maskCanvas.width = currentImageElement.naturalWidth;
            maskCanvas.height = currentImageElement.naturalHeight;
            maskCanvas.style.width = rect.width + 'px';
            maskCanvas.style.height = rect.height + 'px';
            maskCanvas.style.left = (rect.left - containerRect.left) + 'px';
            maskCanvas.style.top = (rect.top - containerRect.top) + 'px';
            maskCanvas.classList.remove('hidden');

            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            maskCtx.strokeStyle = 'white';
            maskCtx.lineWidth = 30; // Adjust brush size
            maskCtx.lineCap = 'round';
            maskCtx.lineJoin = 'round';
        }

        function getEventCoordinates(e) {
            if (e.touches && e.touches.length > 0) {
                return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
            }
            return { clientX: e.clientX, clientY: e.clientY };
        }

        function handleDrawStart(e) {
            if (!isDrawingMode || e.target.closest('.carousel-btn') || e.target.closest('#floating-image-container')) return;

            const currentImageElement = carouselTrack.children[currentImageIndex]?.querySelector('img');
            if (!currentImageElement) return;

            isDrawing = true;
            const coords = getEventCoordinates(e);
            const rect = resultContainer.getBoundingClientRect();

            const maskRect = maskCanvas.getBoundingClientRect();
            lastPos = {
                x: (coords.clientX - maskRect.left) * (maskCanvas.width / maskRect.width),
                y: (coords.clientY - maskRect.top) * (maskCanvas.height / maskRect.height)
            };

            e.preventDefault(); // Prevent default behavior
        }

        function handleDrawMove(e) {
            if (!isDrawing) return;
            const coords = getEventCoordinates(e);

            const maskRect = maskCanvas.getBoundingClientRect();
            const currentPos = {
                x: (coords.clientX - maskRect.left) * (maskCanvas.width / maskRect.width),
                y: (coords.clientY - maskRect.top) * (maskCanvas.height / maskRect.height)
            };

            maskCtx.beginPath();
            maskCtx.moveTo(lastPos.x, lastPos.y);
            maskCtx.lineTo(currentPos.x, currentPos.y);
            maskCtx.stroke();

            lastPos = currentPos;
        }

        function handleDrawEnd() {
            if (!isDrawing) return;
            isDrawing = false;
            showDrawingPromptPopup();
        }

        // Mouse and Touch event listeners
        resultContainer.addEventListener('mousedown', handleDrawStart);
        document.addEventListener('mousemove', handleDrawMove);
        document.addEventListener('mouseup', handleDrawEnd);

        resultContainer.addEventListener('touchstart', handleDrawStart, { passive: false });
        document.addEventListener('touchmove', handleDrawMove, { passive: false });
        document.addEventListener('touchend', handleDrawEnd);

        // Add escape key to exit drawing mode
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isDrawingMode) {
                deactivateDrawingMode();
            }
        });

        // --- Interact.js for Floating Image ---
        function updateTransform(target) {
            const x = parseFloat(target.getAttribute('data-x')) || 0;
            const y = parseFloat(target.getAttribute('data-y')) || 0;
            const angle = parseFloat(target.getAttribute('data-rotate')) || 0;
            target.style.transform = `translate(${x}px, ${y}px) rotate(${angle}deg)`;
        }

        interact(floatingImageContainer).draggable({
            listeners: {
                move(event) {
                    const target = event.target;
                    const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                    const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                    target.setAttribute('data-x', x);
                    target.setAttribute('data-y', y);
                    updateTransform(target);
                }
            },
            inertia: true,
            modifiers: [interact.modifiers.restrictRect({ restriction: 'parent', endOnly: true })]
        });

        interact('#resize-handle').draggable({
            onmove: function (event) {
                const target = floatingImageContainer;
                const rect = target.getBoundingClientRect();
                
                target.style.width = rect.width + event.dx + 'px';
                target.style.height = rect.height + event.dy + 'px';
            },
        });

        interact('#rotate-handle').draggable({
            onmove: function (event) {
                const target = floatingImageContainer;
                const rect = target.getBoundingClientRect();
                const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                
                const angle = Math.atan2(event.clientY - center.y, event.clientX - center.x);
                const currentAngle = (parseFloat(target.getAttribute('data-rotate')) || 0) * (Math.PI / 180);
                const newAngleDeg = (angle * (180 / Math.PI)) + 90; // Adjust for initial handle position
                
                target.setAttribute('data-rotate', newAngleDeg);
                updateTransform(target);
            }
        });
    </script>
</body>
</html>
